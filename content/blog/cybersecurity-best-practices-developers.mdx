---
title: "Cybersecurity Best Practices Every Developer Should Know"
description: "Essential security practices for developers, from input validation to secure authentication and protecting against common vulnerabilities."
date: "2025-02-05"
tags: ["Development"]
featured: false
published: true
author:
  name: "Aiden Kopec"
excerpt: "Learn the fundamental security practices that every developer needs to implement to protect applications and users from common cyber threats."
coverImage: "https://images.unsplash.com/photo-1563986768494-4dee2763ff3f?w=800&h=400&fit=crop&crop=center&auto=format&q=80"
---

# Cybersecurity Best Practices Every Developer Should Know

Security is not an afterthought—it's a fundamental aspect of software development. Every line of code you write has security implications, and understanding these implications is crucial for building applications that protect both your users and your business. Let me share the security practices that every developer should implement from day one.

## Input Validation and Sanitization

### The Foundation of Security

Input validation is your first line of defense against attacks. Never trust user input, even from authenticated users:

```typescript
// Bad - no validation
function createUser(userData: any) {
  const user = {
    name: userData.name,
    email: userData.email,
    role: userData.role
  }
  
  return database.users.create(user)
}

// Good - comprehensive validation
import { z } from 'zod'

const UserSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .regex(/^[a-zA-Z\s]+$/, 'Name can only contain letters and spaces'),
  
  email: z.string()
    .email('Invalid email format')
    .max(255, 'Email too long'),
  
  role: z.enum(['user', 'admin', 'moderator'], {
    errorMap: () => ({ message: 'Invalid role specified' })
  })
})

function createUser(userData: unknown) {
  try {
    const validatedData = UserSchema.parse(userData)
    
    // Additional business logic validation
    if (validatedData.role === 'admin') {
      throw new Error('Cannot create admin users through this endpoint')
    }
    
    return database.users.create(validatedData)
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Validation failed: ${error.errors.map(e => e.message).join(', ')}`)
    }
    throw error
  }
}
```

### SQL Injection Prevention

Always use parameterized queries or ORMs that handle escaping automatically:

```typescript
// Bad - vulnerable to SQL injection
function getUserByEmail(email: string) {
  const query = `SELECT * FROM users WHERE email = '${email}'`
  return database.query(query)
}

// Good - parameterized query
function getUserByEmail(email: string) {
  const query = 'SELECT * FROM users WHERE email = ?'
  return database.query(query, [email])
}

// Better - using an ORM
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function getUserByEmail(email: string) {
  return prisma.user.findUnique({
    where: { email }
  })
}
```

### XSS Prevention

Cross-Site Scripting (XSS) attacks can be devastating. Always escape user content:

```typescript
// Bad - vulnerable to XSS
function renderUserComment(comment: string) {
  return `<div class="comment">${comment}</div>`
}

// Good - escape HTML content
function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

function renderUserComment(comment: string) {
  return `<div class="comment">${escapeHtml(comment)}</div>`
}

// Better - use a library like DOMPurify
import DOMPurify from 'dompurify'

function renderUserComment(comment: string) {
  const sanitizedComment = DOMPurify.sanitize(comment, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
    ALLOWED_ATTR: ['href']
  })
  
  return `<div class="comment">${sanitizedComment}</div>`
}

// Best - use React's built-in XSS protection
function UserComment({ comment }: { comment: string }) {
  return (
    <div className="comment">
      {comment} {/* React automatically escapes this */}
    </div>
  )
}
```

## Authentication and Authorization

### Secure Password Handling

Never store passwords in plain text. Use strong hashing algorithms:

```typescript
import bcrypt from 'bcrypt'
import crypto from 'crypto'

class PasswordService {
  private readonly SALT_ROUNDS = 12
  private readonly MIN_PASSWORD_LENGTH = 8
  
  async hashPassword(password: string): Promise<string> {
    // Validate password strength
    this.validatePassword(password)
    
    // Generate salt and hash
    const salt = await bcrypt.genSalt(this.SALT_ROUNDS)
    return bcrypt.hash(password, salt)
  }
  
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }
  
  private validatePassword(password: string): void {
    if (password.length < this.MIN_PASSWORD_LENGTH) {
      throw new Error(`Password must be at least ${this.MIN_PASSWORD_LENGTH} characters`)
    }
    
    // Check for common patterns
    if (password.toLowerCase().includes('password')) {
      throw new Error('Password cannot contain common words')
    }
    
    // Check for complexity requirements
    const hasUpperCase = /[A-Z]/.test(password)
    const hasLowerCase = /[a-z]/.test(password)
    const hasNumbers = /\d/.test(password)
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password)
    
    if (!(hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar)) {
      throw new Error('Password must contain uppercase, lowercase, number, and special character')
    }
  }
}

// Usage
const passwordService = new PasswordService()

async function createUser(userData: CreateUserRequest) {
  const hashedPassword = await passwordService.hashPassword(userData.password)
  
  return database.users.create({
    ...userData,
    password: hashedPassword
  })
}
```

### JWT Security Best Practices

JSON Web Tokens are powerful but require careful implementation:

```typescript
import jwt from 'jsonwebtoken'
import crypto from 'crypto'

interface JWTPayload {
  userId: string
  email: string
  role: string
  iat: number
  exp: number
}

class JWTService {
  private readonly SECRET_KEY: string
  private readonly ACCESS_TOKEN_EXPIRY = '15m'
  private readonly REFRESH_TOKEN_EXPIRY = '7d'
  
  constructor() {
    this.SECRET_KEY = process.env.JWT_SECRET_KEY!
    
    if (!this.SECRET_KEY || this.SECRET_KEY.length < 32) {
      throw new Error('JWT_SECRET_KEY must be at least 32 characters long')
    }
  }
  
  generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, this.SECRET_KEY, {
      expiresIn: this.ACCESS_TOKEN_EXPIRY,
      issuer: 'your-app',
      audience: 'your-app-users'
    })
  }
  
  generateRefreshToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    const refreshToken = crypto.randomBytes(64).toString('hex')
    
    // Store refresh token hash in database
    const refreshTokenHash = crypto
      .createHash('sha256')
      .update(refreshToken)
      .digest('hex')
    
    // Store hash in database with user ID and expiry
    this.storeRefreshToken(payload.userId, refreshTokenHash)
    
    return refreshToken
  }
  
  verifyToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.SECRET_KEY, {
        issuer: 'your-app',
        audience: 'your-app-users'
      }) as JWTPayload
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Token expired')
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid token')
      }
      throw error
    }
  }
  
  private async storeRefreshToken(userId: string, tokenHash: string): Promise<void> {
    // Store in database with expiry
    await database.refreshTokens.create({
      userId,
      tokenHash,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    })
  }
}

// Middleware for protecting routes
function authenticateToken(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization
  const token = authHeader && authHeader.split(' ')[1] // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' })
  }
  
  try {
    const jwtService = new JWTService()
    const payload = jwtService.verifyToken(token)
    
    // Add user info to request
    req.user = payload
    next()
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' })
  }
}

// Role-based authorization
function requireRole(allowedRoles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' })
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }
    
    next()
  }
}

// Usage
app.get('/admin/users', 
  authenticateToken, 
  requireRole(['admin']), 
  (req, res) => {
    // Only admins can access this endpoint
  }
)
```

### Session Management

Implement secure session handling with proper expiration and rotation:

```typescript
class SessionService {
  private readonly SESSION_SECRET: string
  private readonly SESSION_MAX_AGE = 24 * 60 * 60 * 1000 // 24 hours
  
  constructor() {
    this.SESSION_SECRET = process.env.SESSION_SECRET!
  }
  
  createSession(userId: string): string {
    const sessionId = crypto.randomBytes(32).toString('hex')
    const expiresAt = new Date(Date.now() + this.SESSION_MAX_AGE)
    
    // Store session in database
    database.sessions.create({
      id: sessionId,
      userId,
      expiresAt,
      createdAt: new Date(),
      lastActivity: new Date()
    })
    
    return sessionId
  }
  
  async validateSession(sessionId: string): Promise<string | null> {
    const session = await database.sessions.findUnique({
      where: { id: sessionId }
    })
    
    if (!session || session.expiresAt < new Date()) {
      return null
    }
    
    // Update last activity
    await database.sessions.update({
      where: { id: sessionId },
      data: { lastActivity: new Date() }
    })
    
    return session.userId
  }
  
  async invalidateSession(sessionId: string): Promise<void> {
    await database.sessions.delete({
      where: { id: sessionId }
    })
  }
  
  async invalidateAllUserSessions(userId: string): Promise<void> {
    await database.sessions.deleteMany({
      where: { userId }
    })
  }
}
```

## Data Protection and Privacy

### Encryption at Rest and in Transit

Always encrypt sensitive data:

```typescript
import crypto from 'crypto'

class EncryptionService {
  private readonly ALGORITHM = 'aes-256-gcm'
  private readonly KEY_LENGTH = 32
  private readonly IV_LENGTH = 16
  private readonly AUTH_TAG_LENGTH = 16
  
  constructor() {
    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex')
    
    if (this.encryptionKey.length !== this.KEY_LENGTH) {
      throw new Error('ENCRYPTION_KEY must be 32 bytes (64 hex characters)')
    }
  }
  
  encrypt(text: string): string {
    const iv = crypto.randomBytes(this.IV_LENGTH)
    const cipher = crypto.createCipher(this.ALGORITHM, this.encryptionKey)
    
    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const authTag = cipher.getAuthTag()
    
    // Combine IV, encrypted data, and auth tag
    return iv.toString('hex') + ':' + encrypted + ':' + authTag.toString('hex')
  }
  
  decrypt(encryptedData: string): string {
    const parts = encryptedData.split(':')
    if (parts.length !== 3) {
      throw new Error('Invalid encrypted data format')
    }
    
    const [ivHex, encrypted, authTagHex] = parts
    const iv = Buffer.from(ivHex, 'hex')
    const authTag = Buffer.from(authTagHex, 'hex')
    
    const decipher = crypto.createDecipher(this.ALGORITHM, this.encryptionKey)
    decipher.setAuthTag(authTag)
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}

// Usage for sensitive data
class UserService {
  private encryptionService = new EncryptionService()
  
  async createUser(userData: CreateUserRequest) {
    // Encrypt sensitive fields
    const encryptedSSN = this.encryptionService.encrypt(userData.ssn)
    const encryptedCreditCard = this.encryptionService.encrypt(userData.creditCard)
    
    return database.users.create({
      ...userData,
      ssn: encryptedSSN,
      creditCard: encryptedCreditCard,
      // Don't store password in plain text
      password: await this.hashPassword(userData.password)
    })
  }
  
  async getUserById(id: string) {
    const user = await database.users.findUnique({ where: { id } })
    
    if (!user) return null
    
    // Decrypt sensitive fields
    return {
      ...user,
      ssn: this.encryptionService.decrypt(user.ssn),
      creditCard: this.encryptionService.decrypt(user.creditCard)
    }
  }
}
```

### HTTPS and Transport Security

Always use HTTPS in production and implement security headers:

```typescript
import helmet from 'helmet'
import express from 'express'

const app = express()

// Security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}))

// Additional security middleware
app.use((req, res, next) => {
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY')
  
  // Prevent MIME type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff')
  
  // Referrer policy
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin')
  
  // Permissions policy
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()')
  
  next()
})

// Rate limiting
import rateLimit from 'express-rate-limit'

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false
})

app.use('/api/', limiter)

// Stricter rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 attempts per 15 minutes
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true
})

app.use('/api/auth/', authLimiter)
```

## Common Vulnerability Prevention

### CSRF Protection

Protect against Cross-Site Request Forgery attacks:

```typescript
import csrf from 'csurf'

// CSRF protection middleware
const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
})

// Apply to all routes that modify data
app.use('/api/', csrfProtection)

// Generate CSRF token for forms
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() })
})

// Frontend usage
async function submitForm(formData: FormData) {
  const csrfToken = await fetch('/api/csrf-token').then(r => r.json())
  
  const response = await fetch('/api/submit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'CSRF-Token': csrfToken.csrfToken
    },
    body: JSON.stringify(formData)
  })
  
  return response.json()
}
```

### File Upload Security

Secure file uploads to prevent malicious file execution:

```typescript
import multer from 'multer'
import path from 'path'

class FileUploadService {
  private readonly ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx']
  private readonly MAX_FILE_SIZE = 5 * 1024 * 1024 // 5MB
  
  private storage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'uploads/')
    },
    filename: (req, file, cb) => {
      // Generate unique filename
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)
      cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname))
    }
  })
  
  private fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    // Check file extension
    const ext = path.extname(file.originalname).toLowerCase()
    if (!this.ALLOWED_EXTENSIONS.includes(ext)) {
      return cb(new Error('File type not allowed'))
    }
    
    // Check file size
    if (file.size > this.MAX_FILE_SIZE) {
      return cb(new Error('File too large'))
    }
    
    // Additional security checks
    if (file.mimetype.startsWith('text/')) {
      // Scan text files for malicious content
      this.scanFileContent(file).then(isSafe => {
        if (isSafe) {
          cb(null, true)
        } else {
          cb(new Error('File content not allowed'))
        }
      })
    } else {
      cb(null, true)
    }
  }
  
  private async scanFileContent(file: Express.Multer.File): Promise<boolean> {
    // Implement content scanning logic
    // Check for script tags, executable code, etc.
    const content = file.buffer.toString('utf8')
    
    const dangerousPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /vbscript:/gi,
      /on\w+\s*=/gi
    ]
    
    return !dangerousPatterns.some(pattern => pattern.test(content))
  }
  
  getUploadMiddleware() {
    return multer({
      storage: this.storage,
      fileFilter: this.fileFilter,
      limits: {
        fileSize: this.MAX_FILE_SIZE,
        files: 1
      }
    })
  }
}

// Usage
const fileUploadService = new FileUploadService()
const upload = fileUploadService.getUploadMiddleware()

app.post('/api/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' })
  }
  
  res.json({ 
    message: 'File uploaded successfully',
    filename: req.file.filename
  })
})
```

## Security Testing and Monitoring

### Automated Security Testing

Implement security testing in your CI/CD pipeline:

```typescript
// Security test examples
import { test, expect } from '@playwright/test'

test.describe('Security Tests', () => {
  test('should not expose sensitive information in response headers', async ({ request }) => {
    const response = await request.get('/api/users')
    
    // Check for security headers
    expect(response.headers()).toHaveProperty('x-content-type-options')
    expect(response.headers()).toHaveProperty('x-frame-options')
    expect(response.headers()).toHaveProperty('x-xss-protection')
    
    // Check that sensitive headers are not exposed
    expect(response.headers()).not.toHaveProperty('x-powered-by')
    expect(response.headers()).not.toHaveProperty('server')
  })
  
  test('should prevent SQL injection', async ({ request }) => {
    const maliciousInput = "'; DROP TABLE users; --"
    
    const response = await request.post('/api/users/search', {
      data: { query: maliciousInput }
    })
    
    // Should not return 500 error (which might indicate SQL injection)
    expect(response.status()).not.toBe(500)
    
    // Should return empty results or error message
    const body = await response.json()
    expect(body.users).toEqual([])
  })
  
  test('should prevent XSS attacks', async ({ request }) => {
    const maliciousInput = '<script>alert("xss")</script>'
    
    const response = await request.post('/api/comments', {
      data: { content: maliciousInput }
    })
    
    const comment = await response.json()
    
    // Content should be escaped, not contain script tags
    expect(comment.content).not.toContain('<script>')
    expect(comment.content).toContain('&lt;script&gt;')
  })
})

// Security monitoring
class SecurityMonitor {
  private suspiciousActivities: Array<{
    timestamp: Date
    ip: string
    action: string
    details: any
  }> = []
  
  logSuspiciousActivity(ip: string, action: string, details: any) {
    const activity = {
      timestamp: new Date(),
      ip,
      action,
      details
    }
    
    this.suspiciousActivities.push(activity)
    
    // Alert if too many suspicious activities from same IP
    const recentActivities = this.suspiciousActivities.filter(
      a => a.ip === ip && 
           a.timestamp > new Date(Date.now() - 15 * 60 * 1000) // Last 15 minutes
    )
    
    if (recentActivities.length > 10) {
      this.alertSecurityTeam(ip, recentActivities)
    }
  }
  
  private alertSecurityTeam(ip: string, activities: any[]) {
    // Send alert to security team
    console.warn(`Security alert: Suspicious activity from IP ${ip}`, activities)
  }
}

// Usage in middleware
const securityMonitor = new SecurityMonitor()

app.use((req, res, next) => {
  // Log suspicious patterns
  if (req.body && typeof req.body === 'string') {
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /union\s+select/i,
      /drop\s+table/i
    ]
    
    if (suspiciousPatterns.some(pattern => pattern.test(req.body))) {
      securityMonitor.logSuspiciousActivity(
        req.ip,
        'suspicious_input',
        { body: req.body.substring(0, 100) }
      )
    }
  }
  
  next()
})
```

## Conclusion

Security is not a feature you can add later—it's a fundamental aspect of every application you build. The practices I've shared here provide a solid foundation for building secure applications, but security is an ongoing process that requires:

1. **Continuous learning**: Stay updated on new threats and vulnerabilities
2. **Regular testing**: Implement automated security testing in your development workflow
3. **Code reviews**: Always review code with security in mind
4. **Monitoring**: Implement logging and monitoring to detect attacks
5. **Incident response**: Have a plan for when security incidents occur

Remember that security is about defense in depth. No single measure is perfect, but implementing multiple layers of security significantly reduces your risk. Start with the fundamentals—input validation, authentication, and HTTPS—and gradually add more sophisticated security measures as your application grows.

The cost of implementing security measures is always less than the cost of a security breach. Make security a priority from day one, and your users will thank you for it.
